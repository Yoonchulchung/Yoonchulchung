/**
 * Temporary Prisma type definitions
 * These types should be generated by `prisma generate`
 * This file provides fallback types when Prisma client cannot be regenerated
 */

declare module '@prisma/client' {
  export enum UserRole {
    ADMIN = 'ADMIN',
    USER = 'USER',
  }

  export enum AIProvider {
    OPENAI = 'OPENAI',
    ANTHROPIC = 'ANTHROPIC',
    GOOGLE = 'GOOGLE',
    COHERE = 'COHERE',
    HUGGINGFACE = 'HUGGINGFACE',
  }

  export enum MessageRole {
    USER = 'USER',
    ASSISTANT = 'ASSISTANT',
    SYSTEM = 'SYSTEM',
    FUNCTION = 'FUNCTION',
  }

  // Model types
  export interface User {
    id: string;
    email: string;
    password: string;
    username: string;
    role: UserRole;
    createdAt: Date;
    updatedAt: Date;
  }

  export interface Project {
    id: string;
    title: string;
    description: string;
    content: string;
    imageUrl: string | null;
    demoUrl: string | null;
    githubUrl: string | null;
    tags: string[];
    startDate: Date;
    endDate: Date | null;
    isPublished: boolean;
    order: number;
    createdAt: Date;
    updatedAt: Date;
  }

  export interface Portfolio {
    id: string;
    title: string;
    subtitle: string | null;
    description: string;
    content: string;
    avatarUrl: string | null;
    resumeUrl: string | null;
    email: string | null;
    github: string | null;
    linkedin: string | null;
    website: string | null;
    skills: string[];
    isPublished: boolean;
    createdAt: Date;
    updatedAt: Date;
  }

  export interface ApiKey {
    id: string;
    userId: string;
    provider: AIProvider;
    apiKey: string;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
  }

  export interface ChatSession {
    id: string;
    userId: string;
    title: string;
    model: string;
    provider: AIProvider;
    systemPrompt: string | null;
    temperature: number;
    maxTokens: number;
    useRAG: boolean;
    createdAt: Date;
    updatedAt: Date;
    messages?: ChatMessage[];
    _count?: {
      messages: number;
    };
  }

  export interface ChatMessage {
    id: string;
    sessionId: string;
    role: MessageRole;
    content: string;
    metadata: any;
    createdAt: Date;
  }

  export interface Document {
    id: string;
    title: string;
    content: string;
    source: string | null;
    sourceType: string;
    metadata: any;
    isIndexed: boolean;
    createdAt: Date;
    updatedAt: Date;
  }

  // Array query operators
  interface ArrayQueryOperators<T> {
    has?: T;
    hasSome?: T[];
    hasEvery?: T[];
    isEmpty?: boolean;
  }

  // Prisma operations types
  type WhereInput<T> = {
    [K in keyof T]?: T[K] extends string[]
      ? string[] | ArrayQueryOperators<string>
      : T[K] extends number[]
      ? number[] | ArrayQueryOperators<number>
      : T[K];
  } & {
    id?: string;
    AND?: WhereInput<T>[];
    OR?: WhereInput<T>[];
    NOT?: WhereInput<T>[];
  };

  interface FindManyArgs<T> {
    where?: WhereInput<T>;
    orderBy?: any;
    include?: any;
    select?: any;
    take?: number;
    skip?: number;
  }

  interface FindUniqueArgs<T> {
    where: { id: string } | { email?: string } | { username?: string } | { userId_provider?: { userId: string; provider: AIProvider } };
    include?: any;
    select?: any;
  }

  interface FindFirstArgs<T> {
    where?: WhereInput<T>;
    orderBy?: any;
    include?: any;
    select?: any;
  }

  interface CreateArgs<T> {
    data: Partial<T>;
  }

  interface UpdateArgs<T> {
    where: { id: string };
    data: Partial<T>;
  }

  interface UpsertArgs<T> {
    where: any;
    create: Partial<T>;
    update: Partial<T>;
  }

  interface DeleteArgs {
    where: { id: string };
  }

  interface DeleteManyArgs<T> {
    where?: WhereInput<T>;
  }

  // Model delegates
  interface UserDelegate {
    findUnique(args: FindUniqueArgs<User>): Promise<User | null>;
    findFirst(args?: FindFirstArgs<User>): Promise<User | null>;
    findMany(args?: FindManyArgs<User>): Promise<User[]>;
    create(args: CreateArgs<User>): Promise<User>;
    update(args: UpdateArgs<User>): Promise<User>;
    delete(args: DeleteArgs): Promise<User>;
    deleteMany(args?: DeleteManyArgs<User>): Promise<{ count: number }>;
  }

  interface ProjectDelegate {
    findUnique(args: FindUniqueArgs<Project>): Promise<Project | null>;
    findFirst(args?: FindFirstArgs<Project>): Promise<Project | null>;
    findMany(args?: FindManyArgs<Project>): Promise<Project[]>;
    create(args: CreateArgs<Project>): Promise<Project>;
    update(args: UpdateArgs<Project>): Promise<Project>;
    delete(args: DeleteArgs): Promise<Project>;
    deleteMany(args?: DeleteManyArgs<Project>): Promise<{ count: number }>;
  }

  interface PortfolioDelegate {
    findUnique(args: FindUniqueArgs<Portfolio>): Promise<Portfolio | null>;
    findFirst(args?: FindFirstArgs<Portfolio>): Promise<Portfolio | null>;
    findMany(args?: FindManyArgs<Portfolio>): Promise<Portfolio[]>;
    create(args: CreateArgs<Portfolio>): Promise<Portfolio>;
    update(args: UpdateArgs<Portfolio>): Promise<Portfolio>;
    delete(args: DeleteArgs): Promise<Portfolio>;
    deleteMany(args?: DeleteManyArgs<Portfolio>): Promise<{ count: number }>;
  }

  interface ApiKeyDelegate {
    findUnique(args: FindUniqueArgs<ApiKey>): Promise<ApiKey | null>;
    findFirst(args?: FindFirstArgs<ApiKey>): Promise<ApiKey | null>;
    findMany(args?: FindManyArgs<ApiKey>): Promise<ApiKey[]>;
    create(args: CreateArgs<ApiKey>): Promise<ApiKey>;
    update(args: UpdateArgs<ApiKey>): Promise<ApiKey>;
    upsert(args: UpsertArgs<ApiKey>): Promise<ApiKey>;
    delete(args: DeleteArgs): Promise<ApiKey>;
    deleteMany(args?: DeleteManyArgs<ApiKey>): Promise<{ count: number }>;
  }

  interface ChatSessionDelegate {
    findUnique(args: FindUniqueArgs<ChatSession>): Promise<ChatSession | null>;
    findFirst(args?: FindFirstArgs<ChatSession>): Promise<ChatSession | null>;
    findMany(args?: FindManyArgs<ChatSession>): Promise<ChatSession[]>;
    create(args: CreateArgs<ChatSession>): Promise<ChatSession>;
    update(args: UpdateArgs<ChatSession>): Promise<ChatSession>;
    delete(args: DeleteArgs): Promise<ChatSession>;
    deleteMany(args?: DeleteManyArgs<ChatSession>): Promise<{ count: number }>;
  }

  interface ChatMessageDelegate {
    findUnique(args: FindUniqueArgs<ChatMessage>): Promise<ChatMessage | null>;
    findFirst(args?: FindFirstArgs<ChatMessage>): Promise<ChatMessage | null>;
    findMany(args?: FindManyArgs<ChatMessage>): Promise<ChatMessage[]>;
    create(args: CreateArgs<ChatMessage>): Promise<ChatMessage>;
    update(args: UpdateArgs<ChatMessage>): Promise<ChatMessage>;
    delete(args: DeleteArgs): Promise<ChatMessage>;
    deleteMany(args?: DeleteManyArgs<ChatMessage>): Promise<{ count: number }>;
  }

  interface DocumentDelegate {
    findUnique(args: FindUniqueArgs<Document>): Promise<Document | null>;
    findFirst(args?: FindFirstArgs<Document>): Promise<Document | null>;
    findMany(args?: FindManyArgs<Document>): Promise<Document[]>;
    create(args: CreateArgs<Document>): Promise<Document>;
    update(args: UpdateArgs<Document>): Promise<Document>;
    delete(args: DeleteArgs): Promise<Document>;
    deleteMany(args?: DeleteManyArgs<Document>): Promise<{ count: number }>;
  }

  // PrismaClient options
  interface PrismaClientOptions {
    log?: Array<'query' | 'info' | 'warn' | 'error'>;
    errorFormat?: 'pretty' | 'colorless' | 'minimal';
    datasources?: {
      db?: {
        url?: string;
      };
    };
  }

  // PrismaClient
  export class PrismaClient {
    user: UserDelegate;
    project: ProjectDelegate;
    portfolio: PortfolioDelegate;
    apiKey: ApiKeyDelegate;
    chatSession: ChatSessionDelegate;
    chatMessage: ChatMessageDelegate;
    document: DocumentDelegate;

    constructor(options?: PrismaClientOptions);
    $connect(): Promise<void>;
    $disconnect(): Promise<void>;
    $on(eventType: string, callback: (...args: any[]) => void): void;
    $queryRaw<T = any>(query: TemplateStringsArray, ...values: any[]): Promise<T>;
    $transaction<R>(fn: (prisma: PrismaClient) => Promise<R>, options?: any): Promise<R>;
  }
}
